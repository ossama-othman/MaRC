20 August 2017 - MaRC 0.9.9

- Data generated by the MU, MU0, PHASE, LATITUDE and LONGITUDE virtual
  images are now automatically offset and scaled by the largest power
  of 10 suitable for maximizing the number of significant digits retained
  when storing their floating point values in integer typed maps.  For
  example, MU image data, which has a range of [-1, 1], will be scaled
  and offset to a range of [0, 200] for a map with BYTE (unsigned 8
  bit integer) data, [-10000, 10000] for a SHORT (signed 16 bit
  integer) data type map, and [-1e+09, 1e+09] for LONG (signed 32 bit
  integer) typed maps.

  The virtual image data is only automatically scaled and/or offset
  for integer typed maps.  They are not scaled or offset when creating
  maps with a floating point data type (DATA_TYPE of FLOAT or
  DOUBLE).

  The necessary scale and offset needed to obtain the true values of
  these virtual images in integer typed maps is now automatically
  written to the map FITS header as well.

  NOTE: The hardcoded scale value of 10000 for the MU, MU0 and PHASE
        virtual images that existed in previous versions of MaRC has
        been removed for all map data types.  Due to the automatic
        scaling that now occurs, the results will be the same for
        SHORT map types, but not the other types.  As described above,
        a better scaling factor and offset will be chosen.

- Corrected problem where flat-field correction would fail.

- Improved accuracy of vector magnitude calculations by leveraging an
  implementation that avoids floating point underflow and overflow, as
  well as having extremely low floating point error.

- Improved accuracy of quadratic equation root calculations by using
  an implementation that avoids loss of significant digits
  (i.e. catastrophic cancellation).  This impacts the sky removal
  feature and the Orthographic map projection.

- LONG map types are now correctly written to the map FITS file on 64
  bit platforms where the fundamental C language 'long' integer type
  is 8 bytes wide.

- Improved memory management.
  - Better C++ exception safety.
  - Reduced run-time memory requirements.
  - Slighty improved performance due to less deep copies of large
    arrays.

- Fixed inversion of source photo images from left to right and top to
  bottom.

- Support for maps containing 64 bit signed integer data has been
  added.  Set DATA_TYPE in your MaRC input file to LONGLONG to use
  this feature.

- Fixed problem where negative data was not plotted in maps with a
  floating point data type.

- Initial support for Doxygen based MaRC source code documentation
  generation is now available.  Assuming Doxygen is installed, run
  `make doxygen-doc' from the top-level MaRC source directory to
  generate MaRC library and program source code documentation.
  Generated documentation will reside in the doc/doxygen directory.

24 July 2017 - MaRC 0.9.8

- MaRC now requires C++14 conforming compilers.  The 'configure'
  script will attempt to detect and enable C++14 support in the C++
  compiler in use. Verified to build with g++ 6.3 and Clang++ 3.9.
- Modernized the build infrastructure to leverage the latest versions
  of the GNU autotools (Autoconf, Automake and Libtool).  This should
  provide better build support on more platforms, particularly recent
  ones.
- MaRC now passes the static analysis scan run through Coverity (see
  https://scan.coverity.com/projects/ossama-othman-marc).
- Added better support for automated detection of CPU tuning compiler
  flags.
- Updated LPGL license terms from 2.0 to 2.1.
- Updated GFDL license terms from 1.2 to 1.3.
- Minor optimizations.
- Slight reduction in static footprint.
- Fixed a bug MaRC::Vector iteration problem that prevented properly
  mapping images where the latitude and longitude at the optical axis
  ({LAT,LON}_AT_CENTER) instead of the of body center
  ({SAMPLE,LINE}_CENTER were given.  Support for the LAT_AT_CENTER and
  LON_AT_CENTER MaRC input file keywords is still disabled, however,
  since the fix is still somewhat experimental.

11 November 2005 - MaRC 0.9.7

- Fixed latitude/longitude visibility calculation so that it correctly
  takes into account an optical axis that is not in line with the
  sub-observation point.

9 November 2005 - MaRC 0.9.6

- Reduced floating point computation error when image focal length and
  scale are available.
- Fixed logic error that prevented images from being mapped
  correctly.

8 February 2005 - MaRC 0.9.5

- Fixed map corruption and redundant mapping problems that occured
  when specifying more than one MaRC input file on the command line to
  parse.
- MaRC input file PDF documentation now contains a section menu and
  hyperlinks with the document text.

8 November 2004 - MaRC 0.9.4

- Removed dependency on FlexLexer.h when building MaRC.
- Added several regression tests.  Try "make check".

3 November 2004 - MaRC 0.9.3

- Enhanced C library NaN constant detection to support additional ways
  of retrieving the NaN constant.  Addresses build errors on Solaris.

2 November 2004 - MaRC 0.9.2

- Added support for Transverse Mercator projection.  It is a conformal
  projection, i.e. it preserves shape.
- Added support for Polar Stereographic projects.  It too is a
  conformal projection.
- Fixed configuration problem on Solaris.

13 October 2004 - MaRC 0.9.1

- Fixed mosaic averaging code regression so that seams in image
  overlap regions are once again barely visible when averaging images
  taken by the same instrument at the same settings (e.g. wavelength).
- Slight speed improvement due to replacement of old TNT matrix code
  with MaRC-specific simple and fast matrix/vector implementation.
- Fixed a memory leak and a few potential ones.
- Addressed problem where longitudes in a "longitude map" were not
  wrapped into a 360 degree range.
- Added support for GNU g++ 3.4.2.

6 July 2004 - MaRC 0.9

- Major code rewrite.  Much cleaner and better designed and organized.
- MaRC now requires modern compilers that support most ANSI/ISO C++
  features.  Currently tested with GNU g++ 2.95, 3.2.2 and 3.4.0 on
  Linux.
- Added two new types of map planes "LATITUDE" and "LONGITUDE", which
  contain maps of the latitudes and longitudes in degrees,
  respectively.
- Many areas of MaRC have been further optimized.
- Geometric and photometric correction techniques are now "pluggable."
- CFITSIO is the underlying FITS library in MaRC, replacing AIPS++.
  This provides MaRC with all of the FITS file benefits provided by
  CFITSIO, such as on-the-fly FITS file compression/decompression.
- Added support for adding "AUTHOR", "ORIGIN" and "BLANK" FITS
  keywords to map FITS file.
- Sky removal feature no longer modifies source image, reducing the
  chances of losing valid data when mapping.
- Disabled all map projections except for Orthographic and Simple
  Cylindrical.  The others have not yet been ported to the new MaRC
  library API.
- MaRC is now distributed under the terms set forth in the GNU General
  Public License (GPL) and the GNU Lesser General Public License (LGPL).

18 November 1997

- Updated coordinate transformation matrix computations.
  Transformation should now be correct.  The update allows MaRC to
  take into account the fact the camera may not be looking directly at
  the sub-observation point.
- Added a perspective projection.  (STILL EXPERIMENTAL)
- Added code to use weighted averages when mapping in overlap regions.
  Seams are virtually invisible when mapping source images that were
  taken with the same instrument.
- Many code fixes and clean ups.
- Added some support for reading VICAR files.

30 May 1997

- Memory is now handled very differently.  The new memory scheme uses
  MUCH less memory for multi-plane maps than previously.  Memory
  requirements depend ONLY on the number of samples and lines in the
  desired map.  This means that a map with 20 planes would take up the
  same amount of memory as a 1 plane map during mapping!  Of course,
  additional memory is still required to handle the additional images
  in the image queue, but this memory requirement is insignificant
  compared to the memory savings of the new memory usage scheme.
- Negative values may now be mapped on "SHORT" (16-bit) integer maps.
